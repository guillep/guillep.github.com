@booklet{Poli20z,
  author = {Guillermo Polito and St\'ephane Ducasse and Pablo Tesone and Ted Brunzie},
  title = {Unified FFI - Calling Foreign Functions from Pharo},
  pages = {67},
  publisher = {Square Bracket Associates},
  year = {2020},
  url = {http://books.pharo.org/booklet-uffi/},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo Technology Collection},
  keywords = {skipdoi kzPharo kzTools lse-pub},
  pdf = {http://books.pharo.org/booklet-uffi/pdf/2020-02-12-uFFI-V1.0.1.pdf}
 }

@booklet{Poli20y,
  author = {Guillermo Polito and St\'ephane Ducasse and Allex Oliveira},
  title = {Manage Your Code with Git and Iceberg},
  pages = {61},
  publisher = {Square Bracket Associates},
  year = {2020},
  url = {http://books.pharo.org/booklet-uffi/},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo Technology Collection},
  keywords = {skipdoi kzPharo kzTools lse-pub},
  pdf = {http://books.pharo.org/booklet-ManageCode/pdf/2020-05-12-ManageCode.pdf}
 }
 


 @booklet{Duca20y,
   author = {St\'ephane Ducasse and Guillermo Polito},
   title = {Concurrent Programming in Pharo},
   pages = {52},
   publisher = {Square Bracket Associates},
   year = {2020},
   url = {http://books.pharo.org/booklet-ConcurrentProgramming/},
   annote = {booklet editor},
   editor = {St\'ephane Ducasse},
   collection = {The Pharo Technology Collection},
   keywords = {skipdoi kzPharo kzTools lse-pub},
   pdf = {http://books.pharo.org/booklet-ConcurrentProgramming/pdf/2020-02-18-Concur.pdf}
  }


 @inproceedings{Brag19,
   author = {Santiago Bragagnolo and Matte Marra and Guillermo Polito and Elisa Gonzalez Boix},
   title = {Towards Scalable Blockchain Analysis},
   booktitle = {2019 IEEE/ACM 2nd International Workshop on Emerging Trends in Software Engineering for Blockchain (WETSEB)},
   pages = {1-7},
   year = {2019},
   doi = {10.1109/WETSEB.2019.00007},
   annote = {internationalworkshop},
   abstract = {Analysing the blockchain is becoming more and more relevant for detecting attacks and frauds on cryptocurrency exchanges and smart contract activations. However, this is a challenging task due to the continuous growth of the blockchain. For example, in early 2017 Ethereum was estimated to contain approximately 300GB of data [1], a number that keeps growing day after day. In order to analyse such ever-growing amount of data, this paper argues that blockchain analysis should be treated as a novel type of application for Big Data platforms. In this paper we explore the application of parallelization techniques from the Big Data domain, in particular Map/Reduce, to extract and analyse information from the blockchain. We show that our approach significantly improves the index generation by 7.77 times, with a setup of 20 worker nodes, 1 Ethereum node and 1 Database node. We also share our findings of our massively parallel setup for querying Ethereum in terms of architecture and the bottlenecks. This should help researchers setup similar infrastructures for analysing the blockchain in the future.}}
   


@techreport{Delp18b,
     author = {Delplanque, Julien and Ducasse, St\'ephane and Black, Andrew P. and Polito, Guillermo},
     title = {Rotten Green Tests: a First Analysis},
     year = {2018},
     pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Delp18b-RottenTests.pdf},
     annote = {techreport},
     abstract = {Unit tests are a tenant of agile programming methodologies, and are widely used to improve code quality and prevent code regression. A passing (green) test is usually taken as a robust sign that the code under test is valid. However, we have noticed that some green tests contain assertions that are never executed; these tests pass not because they assert properties that are true, but because they assert nothing at all. We call such tests Rotten Green Tests. Rotten Green Tests represent a worst case: they report that the code under test is valid, but in fact do nothing to test that validity, beyond checking that the code does not crash. We describe an approach to identify rotten green tests by combining simple static and dynamic analyses. Our approach takes into account test helper methods, inherited helpers, and trait compositions, and has been implemented in a tool called DrTest. We have applied DrTest to several test suites in Pharo 7.0, and identified many rotten tests, including some that have been " sleeping " in Pharo for at least 5 years.},
     institution = {Inria},
     keywords = {moose StefPub kzChecking kzTools lse-pub},
     hal-id = {hal-01819302}}
     

@inproceedings{Delp19a,
       author = {Delplanque, Julien and Ducasse, St\'ephane and Black, Andrew P. and Polito, Guillermo and Etien, Anne},
       title = {Rotten Green Tests},
       booktitle = {2019 International Conference on Software Engineering (ICSE)},
       year = {2019},
       pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Delp19a-RottenGreenTests-ICSE2019-v2.pdf},
       abstract = {Unit tests are a tenant of agile programming methodologies, and are widely used to improve code quality and prevent code regression. A green (passing) test is usually taken as a robust sign that the code under test is valid. However, some green tests contain assertions that are never executed. We call such tests Rotten Green Tests. Rotten Green Tests represent a case worse than a broken test: they report that the code under test is valid, but in fact do not test that validity. We describe an approach to identify rotten green tests by combining simple static and dynamic call-site analyses. Our approach takes into account test helper methods, inherited helpers, and trait compositions, and has been implemented in a tool called DrTest. DrTest reports no false negatives, yet it still reports some false positives due to conditional use or multiple test contexts. Using DrTest we conducted an empirical evaluation of 19,905 real test cases in mature projects of the Pharo ecosystem. The results of the evaluation show that the tool is effective; it detected 294 tests as rotten-green tests that contain assertions that are not executed. Some rotten tests have been "sleeping" in Pharo for at least 5 years.},
       institution = {Inria},
       pages = {500--511},
       doi ={10.1109/ICSE.2019.00062},
       publisher = {IEEE/ACM},
       keywords = {lse-pub kzChecking},
       hal-id = {hal-02002346},
       hal-url = {https://hal.inria.fr/hal-02002346},
       annote = {topconference internationalconference}}
       

@inproceedings{Dias15b,
         author = {Mart\'in Dias and Guillermo Polito and Damien Cassou and St\'ephane Ducasse},
         title = {DeltaImpactFinder: Assessing Semantic Merge Conflicts with Dependency Analysis},
         booktitle = {IWST'15: International Workshop on Smalltalk Technologies 2015},
         year = {2015},
         url = {https://hal.inria.fr/hal-01199035},
         abstract = {In software development, version control systems (VCS) provide branching and merging support tools. Such tools are popular among developers to concurrently change a codebase in separate lines and reconcile their changes automatically afterwards. However, two changes that are correct independently can introduce bugs when merged together. We call semantic merge conflicts this kind of bugs.
       Change impact analysis (CIA) aims at estimating the effects of a change in a codebase. In this paper, we propose to detect semantic merge conflicts using CIA. On a merge, DELTAIMPACTFINDER analyzes and compares the impact of a change in its origin and destination branches. We call the difference between these two impacts the delta-impact. If the delta-impact is empty, then there is no indicator of a semantic merge conflict and the merge can continue automatically. Otherwise, the delta-impact contains what are the sources of possible conflicts.},
         annote = {internationalworkshop},
         keywords = {pharo lse-pub kzMerging kzMeta},
         pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dias15b-IWST-DeltaImpactFinder.pdf},
         hal-id = {hal-01199035}}
         


@techreport{Duca12a,
  author = {Ducasse, St\'ephane and Petton, Nicolas and Polito, Guillermo and Cassou, Damien},
  title = {Semantics and Security Issues in JavaScript},
  year = {2012},
  abstract = {There is a plethora of research articles describing the deep semantics of JavaScript. Nevertheless, such articles are often difficult to grasp for readers not familiar with formal semantics. In this report, we propose a digest of the semantics of JavaScript centered around security concerns. This document proposes an overview of the JavaScript language and the misleading semantic points in its design. The first part of the document describes the main characteristics of the language itself. The second part presents how those characteristics can lead to problems. It finishes by showing some coding patterns to avoid certain traps and presents some ECMAScript 5 new features.},
  annote = {technicalreport},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {JavaScript Dynamic Language Security Isolation Semantics Web HTTP lse-pub stefPub kzLanguageDesign}}
  
@techreport{Duca12z,
    author = {St\'ephane Ducasse and Nicolas Petton and Guillermo Polito and Damien Cassou},
    title = {Semantics and Security Issues in JavaScript},
    year = {2012},
    pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Duca12z-deliverable-7321-FUI12.pdf},
    annote = {technicalreport},
    institution = {Inria Lille-Nord Europe},
    keywords = {kzLanguageDesign stefPub lse-pub},
    month = dec,
    note = {Deliverable Resilience FUI 12: 7.3.2.1 Failles de s\'ecurit\'e en JavaScript / JavaScript security issues}}
  
@booklet{Duca18d,
  author = {St\'ephane Ducasse and Guillermo Polito},
  title = {Physche: A Little Scheme in Pharo},
  pages = {50},
  publisher = {Square Bracket Associates},
  year = {2018},
  url = {http://books.pharo.org},
  annote = {booklet editor},
  editor = {St\'ephane Ducasse},
  collection = {The Pharo TextBook Collection},
  keywords = {kzSmalltalk lse-pub kzVulgarisation},
  pdf = {http://rmod-files.lille.inria.fr/Team/Books/2018-08-28-Physche.pdf},
  hal-id = {hal-01900327}}
  

@inproceedings{Dupr17a,
    author = {Thomas Dupriez and Guillermo Polito and St\'ephane Ducasse},
    title = {Analysis and exploration for new generation debuggers},
    booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
    pages = {5:1--5:6},
    publisher = {ACM},
    year = {2017},
    doi = {10.1145/3139903.3139910},
    pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dupr17a-IWST-NewGenerationDebuggers.pdf},
    annote = {internationalworkshop},
    abstract = {Locating and fixing bugs is a well-known time consuming task. Advanced approaches such as object-centric or back-in-time debuggers have been proposed in the literature, still in many scenarios developers are left alone with primitive tools such as manual breakpoints and execution stepping. In this position paper we explore several advanced on-line debugging techniques such as advanced breakpoints and on-line execution comparison, that could help developers solve complex debugging scenarios. We analyse the challenges and underlying mechanisms required by these techniques. We present some early but promising prototypes we built on the Pharo programming language. We finally identify future research paths by analysing existing research and connecting it to the techniques we presented before.},
    hal-url = {https://hal.archives-ouvertes.fr/hal-01585338},
    series = {IWST '17},
    isbn = {978-1-4503-5554-4},
    location = {Maribor, Slovenia},
    articleno = {5},
    numpages = {6},
    acmid = {3139910},
    address = {New York, NY, USA},
    keywords = {Debugger ; Tool ; Stack ; Breakpoint ; Watchpoint; lse-pub kzInfrastructure},
    hal-id = {hal-01585338}}

@inproceedings{Dupr19a,
    author = {Dupriez, Thomas and Polito, Guillermo and Costiou, Steven and Aranega, Vincent and Ducasse, St\'ephane},
    title = {Sindarin: A Versatile Scripting API for the Pharo Debugger},
    booktitle = {ACM SIGPLAN International Symposium on Dynamic Languages (DSL'19)},
    year = {2019},
    doi = {10.1145/3359619},
    pages = {67--79},
    publisher = {ACM},
    pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Dupr19a-DLS2019-Official.pdf},
    hal-url = {https://hal.archives-ouvertes.fr/hal-02280915v1},
    hal-id = {hal-02280915},
    annote = {internationalconference},
    keywords = {StefPub kzTools}}
    
@inproceedings{Hern19a,
      author = {Hern\`andez Phillips, Carolina and Guillermo Polito and Luc Fabresse and  St\'ephane Ducasse and Noury Bouraqadi and Pablo Tesone},
      title = {Challenges in Debugging Bootstraps of Reflective Kernels},
      booktitle = {{IWST19 - International workshop on Smalltalk Technologies}},
      year = {2019},
      hal-id = {hal-02297710},
      annote = {internationalworkshop},
      pdf = {https://hal.archives-ouvertes.fr/hal-02297710/file/challengesInBootstrappingReflectiveKernels-corrected.pdf},
      keywords = {IoT ; bootstrap ; language kernels}}
      
@inproceedings{Mar17a,
        author = {Matteo Marra and Elisa Gonzalez Boix and Steven Costiou and Micka\"el Kerboeuf and Alain Plantec and Guillermo Polito and St\'ephane Ducasse},
        title = {Debugging Cyber-Physical Systems with Pharo},
        booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
        pages = {8:1--8:10},
        publisher = {ACM},
        year = {2017},
        url = {https://hal.archives-ouvertes.fr/hal-01585349},
        doi = {10.1145/3139903.3139913},
        annote = {internationalworkshop},
        abstract = {Cyber-Physical Systems (CPS) integrate sensors and actua-tors to collect data and control entities in the physical world. Debugging CPS systems is hard due to the time-sensitive nature of a distributed applications combined with the lack of control on the surrounding physical environment. This makes bugs in CPS systems hard to reproduce and thus to fix. In this context, on-line debugging techniques are helpful because the debugger is connected to the device when an exception or crash occurs. This paper reports on our experiences on applying two different on-line debugging techniques for a CPS system: remote debugging using the Pharo remote debugger and our IDRA debugger. In contrast to traditional remote debug-ging, IDRA allows to on-line debug an application locally in another client machine by reproducing the runtime context where the bug manifested. Our qualitative evaluation shows that IDRA provides almost the same interaction capabilities than Pharo's remote debugger and is less intrusive when performing hot-modifications. Our benchmarks also show that IDRA is significantly faster than the Pharo remote debugger, although it increases the amount of data transferred over the network.},
        series = {IWST '17},
        isbn = {978-1-4503-5554-4},
        location = {Maribor, Slovenia},
        articleno = {8},
        numpages = {10},
        address = {New York, NY, USA},
        keywords = {Cyber-Physical Systems ; software tools ; debugging; lse-pub kzInfrastructure},
        pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Mar17a-IWST-DebuggingIoT.pdf},
        hal-id = {hal-01585349}}
        
@article{Marr18a,
  author = {Marra, Matteo and Polito, Guillermo and Gonzalez Boix, Elisa},
  title = {{Out-Of-Place debugging: a debugging architecture to reduce debugging interference}},
  journal = {{The Art, Science, and Engineering of Programming}},
  volume = {3},
  publisher = {{aosa, Inc.}},
  year = {2018},
  url = {https://hal.inria.fr/hal-01952790},
  doi = {10.22152/programming-journal.org/2019/3/3},
  abstract = {Context Recent studies show that developers spend most of their programming time testing, verifying and debugging software. As applications become more and more complex, developers demand more advanced debugging support to ease the software development process. Inquiry Since the 70's many debugging solutions have been introduced. Amongst them, online debuggers provide good insight on the conditions that led to a bug, allowing inspection and interaction with the variables of the program. However, most of the online debugging solutions introduce debugging interference to the execution of the program, i.e. pauses, latency, and evaluation of code containing side-effects. Approach This paper investigates a novel debugging technique called out-of-place debugging. The goal is to minimize the debugging interference characteristic of online debugging while allowing online remote capabilities. An out-of-place debugger transfers the program execution and application state from the debugged application to the debugger application, each running in a different process. Knowledge On the one hand, out-of-place debugging allows developers to debug applications remotely, overcoming the need of physical access to the machine where the debugged application is running. On the other hand, debugging happens locally on the remote machine avoiding latency. That makes it suitable to be deployed on a distributed system and handle the debugging of several processes running in parallel. Grounding We implemented a concrete out-of-place debugger for the Pharo Smalltalk programming language. We show that our approach is practical by running several benchmarks, comparing our approach with a classic remote online debugger. We show that our prototype debugger outperforms a traditional remote debugger by 1000 times in several scenarios. Moreover, we show that the presence of our debugger does not impact the overall performance of an application. Importance This work combines remote debugging with the debugging experience of a local online debug-ger. Out-of-place debugging is the first online debugging technique that can minimize debugging interference while debugging a remote application. Yet, it still keeps the benefits of online debugging (e.g., step-by-step execution). This makes the technique suitable for modern applications which are increasingly parallel, distributed and reactive to streams of data from various sources like sensors, UI, network, etc.},
  number = {2},
  month = nov,
  keywords = {debugging tools ; online debugging ; remote debugging ; distributed systems; lse-pub; pharo},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Marr18a-Programming18-OutOfPlaceDebugging.pdf},
  hal-id = {hal-01952790}}
  
@inproceedings{Miss19a,
  author = {Misse-Chanabier, Pierre and Aranega, Vincent and Polito, Guillermo and Ducasse, St\'ephane},
  title = {Illicium A modular transpilation toolchain from Pharo to C},
  booktitle = {International workshop of Smalltalk Technologies},
  year = {2019},
  address = {K{\"o}ln, Germany},
  month = aug,
  annote = {internationalworkshop},
  keywords = {kzVM lse-pub},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02297860/file/final_submission.pdf},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Miss19a-IWST-Transpilation.pdf},
  hal-url = {https://hal.archives-ouvertes.fr/hal-02297860},
  hal-id = {hal-02297860}}
  
@inproceedings{Poli13a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury},
  title = {Virtual Smalltalk Images: Model and Applications},
  booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 21th International Smalltalk Conference - 2013},
  year = {2013},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli13a-IWST13-ObjectSpacesVirtualization.pdf},
  abstract = {Reflective architectures are a powerful solution for code browsing, debugging or in-language process handling. However, these reflective architectures show some limitations in edge cases of self-modification and self-monitoring. Modifying the modifier process or monitoring the monitor process in a reflective system alters the system itself, leading to the impossibility to perform some of those tasks properly. In this paper we analyze the problems of reflective architectures in the context of image based object-oriented languages and solve them by providing a first-class representation of an image: a virtualized image.
We present Oz, our virtual image solution. In Oz, a virtual image is represented by an object space. Through an object space, an image can manipulate the internal structure and control the execution of other images. An Oz object space allows one to introspect and modify execution information such as processes, contexts, existing classes and objects. We show how Oz solves the edge cases of reflective architectures by adding a third participant, and thus, removing the self modification and self-observation constraints.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-00924932},
  keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection StefPub}}

@techreport{Poli14a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Bouraqadi, Noury and Fabresse, Luc},
  title = {{Extended results of Tornado: A Run-Fail-Grow approach for Dynamic Application Tayloring}},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Poli14-TechReport-Tornado-INRIA.pdf},
  abstract = {Producing a small deployment version of an application is a challenge because static abstractions such as packages cannot anticipate the use of their parts. As such, an application often occupies more memory than actually needed. To solve this problem we propose Tornado, a technique to dynamically tailor applications to only embed code (classes and methods) they use. Tornado uses a run-fail-grow approach to prepare an application for deployment. It launches minimal version of an application and installs a minimal set of statements that will start the user's application. This application is run and these statements are executed. When the application fails because there are classes or methods missing, the necessary code is installed. The application is executed until it reaches a stable point, allowing possibly human interaction for applications with UIs. Thus, Tornado creates minimal memory footprint versions of applications by tailoring the whole application's code, including run-time and third party libraries. We used Tornado to tailor two different applications. We succeeded to tailor a hello world application to occupy 1% of its original size. We also experimented with a Seaside web application tailoring in one case only the application's and framework's code and the whole application's code in the other case. In this latter example, we reached memory savings of about 97%. In this report we present an overview on Tornado, and we give details of the results we obtained.},
  annote = {technicalreport},
  institution = {RMod -- INRIA Lille-Nord Europe},
  keywords = {kzReflection kzRemodularisation},
  x-pays = {FR}}

@inproceedings{Poli14b,
  author = {Polito, Guillermo and Bouraqadi, Noury and Ducasse, St\'ephane and Fabresse, Luc},
  title = {Understanding Pharo\'s global state to move programs through time and space},
  booktitle = {IWST - International Workshop on Smalltalk Technology, Co-located within the 22th International Smalltalk Conference - 2014},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli14b-IWST-GlobalStateClassification.pdf},
  abstract = {Code mobility is a mechanism that allows the migration of running programs between different environments. Such migration includes amongst others the migration of application data and resources. Application\'s data is is usually composed by elements of different nature: from printers and files, to framework and domain objects. This application data will be transported along with the code of its program in space (when serialized and deployed in another environment) or time (when a new session is started in a different point of time). The main problem when moving around code resides, in our understanding, to global state. While unreferenced leaf objects are garbage collected, those referenced (transitively) by some global object will remain alive. In order to support code mobility in time and space, we need to understand how global application data is used. With this purpose, we study and classify Pharo\'s global state. This classification uncovers some common patterns and provides a first insight on how global state should be managed, specially in code mobility scenarios. As a minor contribution, we also discuss solutions to each of the found categories.},
  annote = {internationalworkshop},
  audience = {international},
  hal-id = {hal-01070964},
  keywords = {lse-pub globalstate stefpub kzEvolution kzPharo}}

@article{Poli14c,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury and van Ryseghem, Benjamin},
  title = {Bootstrapping Reflective Systems: The Case of Pharo},
  volume = {96},
  pages = {141-155},
  doi = {10.1016/j.scico.2013.10.008},
  journal = {Science of Computer Programming},
  publisher = {Elsevier},
  year = {2014},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli14c-BootstrappingASmalltalk-ScienceOfComputerProgramming.pdf},
  abstract = {Bootstrapping is a technique commonly known by its usage in language definition by the introduction of a compiler written in the same language it compiles.
	This process is important to understand and modify the definition of a given language using the same language, taking benefit of the abstractions and expression power it provides. A bootstrap, then, supports the evolution of a language. However, the infrastructure of reflective systems like Smalltalk includes, in addition to a compiler, an environment with several self-references. A reflective system bootstrap should consider all its infrastructural components.
	In this paper, we propose a definition of bootstrap for object-oriented reflective systems, we describe the architecture and components it should contain and we analyze the challenges it has to overcome. Finally, we present a reference bootstrap process for a reflective system and Hazelnut, its implementation for bootstrapping the Pharo Smalltalk-inspired system.},
  annote = {internationaljournal},
  hal-id = {hal-00903724},
  keywords = {lse-pub virtualization metacircularities recovery isolation kzReflection stefpub}}

@inproceedings{Poli15a,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury},
  title = {A Bootstrapping Infrastructure to Build and Extend Pharo-Like Languages},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15a-Onward-Bootstrapping.pdf},
  abstract = {Bootstrapping is well known in the context of compilers, where a bootstrapped compiler can compile its own source code. Bootstrapping is a beneficial engineering practice because it raises the level of abstraction of a program making it easier to understand, optimize, evolve, etc. Bootstrapping a reflective object-oriented language is however more challenging, as we need also to initialize the runtime of the language with its initial objects and classes besides writing its compiler.
In this paper, we present a novel bootstrapping infrastructure for Pharo-like languages that allows us to easily extend and modify such languages. Our bootstrapping process relies on a first-class runtime. A first-class runtime is a meta-object that represents a program's runtime and provides a MOP to easily load code into it and manipulate its objects. It decouples the virtual machine (VM) and language concerns by introducing a clear VM-language interface. Using this process, we show how we succeeded to bootstrap a Smalltalk-based language named Candle and then extend it with traits in less than 250 lines of high-level Smalltalk code. We also show how we can bootstrap with minimal effort two other languages (Pharo and MetaTalk) with similar execution semantics but different object models.},
  annote = {internationalconference},
  hal-id = {hal-01185812},
  keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15a-Onward-Bootstrapping.pdf}}

@inproceedings{Poli15b,
  author = {Polito, Guillermo and Ducasse, St\'ephane and Fabresse, Luc and Bouraqadi, Noury and Mattone, Max},
  title = {Virtualization Support for Dynamic Core Library Update},
  booktitle = {Onward! 2015},
  year = {2015},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf},
  abstract = {Dynamically updating language runtime and core libraries such as collections and threading is challenging since the update mechanism uses such libraries at the same time that it modifies them. To tackle this challenge, we present Dy- namic Core Library Update (DCU) as an extension of Dy- namic Software Update (DSU) and our approach based on a virtualization architecture. Our solution supports the up- date of core libraries as any other normal library, avoiding the circular dependencies between the updater and the core libraries. Our benchmarks show that there is no evident per- formance overhead in comparison with a default execution. Finally, we show that our approach can be applied to real life scenario by introducing a critical update inside a web application with 20 simulated concurrent users.},
  annote = {internationalconference},
  hal-id = {hal-01185819},
  keywords = {lse-pub globalstate kzLanguageDesign kzReflection stefpub},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli15b-Onward-CoreLibrariesHotUpdate.pdf}}

@phdthesis{Poli15d,
  author = {Guillermo Polito},
  title = {Virtualization Support for Application Runtime Specialization and Extension},
  year = {2015},
  school = {University Lille 1 - Sciences et Technologies - France},
  pdf = {http://rmod-files.lille.inria.fr/Team/PhDs/PhD-2015-Polito.pdf},
  hal-id = {tel-01251173v1},
  abstract = {An application runtime is the set of software elements that represent an application during its execution. Application runtimes should be adaptable to different contexts. Advances in computing technology both in hardware and software indeed demand it. For example, on one hand we can think about extending a programming language to enhance the developers' productivity. On the other hand we can also think about transparently reducing the memory footprint of applications to make them fit in constrained resource scenarios e.g., low networks or limited memory availability. We propose Espell, a virtualization infrastructure for object-oriented high-level language runtimes. Espell provides a general purpose infrastructure to control and manipulate object-oriented runtimes in different situations. A first-class representation of an object-oriented runtime provides a high-level API for the manipulation of such runtime. A hypervisor uses this first-class object and manipulates it either directly or by executing arbitrary expressions into it. We show with our prototype that this infrastructure supports language bootstrapping and application runtime tailoring. Using bootstrapping we describe an object-oriented high-level language initialization in terms of itself. A bootstrapped language takes advantage of its own abstractions and is easier to extend. With application runtime tailoring we generate specialized applications by extracting the elements of a program that are used during execution. A tailored application encompasses only the classes and methods it needs and avoids the code bloat that appears from the usage of third-party libraries and frameworks.},
  month = {apr}}

@techreport{Poli17a,
  author = {St\'ephane Ducasse and Luc Fabresse and Guillermo Polito and Camille Teruel},
  title = {An Experiment with lexically-bound extension methods for a dynamic language},
  year = {2017},
  url = {https://hal.inria.fr/hal-01483756},
  annote = {techreport},
  abstract = {An extension method is a method declared in a package other than the package of its host class. Thanks to extension methods, developers can adapt classes they do not own to their needs: adding methods to core classes is a typical use case. This is particularly useful for adapting software and therefore increasing reusability. In most dynamically-typed languages, extension methods are globally visible. Because any developer can define extension methods for any class, naming conflicts occur: if two developers define an extension method with the same signature in the same class, only one extension method is visible and overwrites the other. Similarly, if two developers each define an extension method with the same name in a class hierarchy, one overrides the other. Existing solutions typically rely on a dedicated and slow method lookup algorithm to resolve conflicts at runtime. In this article, we present a model of scoped extension methods that minimizes accidental overrides and we present an implementation in Pharo that incurs little performance overhead. This implementation is based on lexical scope and hierarchy-first strategy for extension scoping.},
  month = mar,
  keywords = {modularity ; extension methods ; Pharo ; lse-pub kzLanguageDesign},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers//Poli17a-TR-ExtensionMethods.pdf},
  institution = {Inria Lille-Nord Europe},
  hal-id = {tel-01352817}}

@inproceedings{Poli17b,
  author = {Guillermo Polito and St\'ephane Ducasse and Luc Fabresse},
  title = {First-Class Undefined Classes for Pharo},
  booktitle = {Proceedings of the 12th Edition of the International Workshop on Smalltalk Technologies},
  pages = {9:1--9:8},
  publisher = {ACM},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01585305},
  doi = {10.1145/3139903.3139914},
  annote = {internationalworkshop},
  abstract = {Loading code inside a Pharo image is a daily concern for a Pharo developer. Nevertheless, several problems may arise at loading time that can prevent the code to load or even worse let the system in an inconsistent state. In this paper, we focus on the problem of loading code that references a class that does not exist in the system. We discuss the different flavors of this problem, the limitations of the existing Undeclared mechanism and the heterogeneity of Pharo tools to solve it. Then, we propose an unified solution for Pharo that reifies Undefined Classes. Our model of Undefined Classes is the result of an objective selection among different alternatives. We then validate our solution through two cases studies: migrating old code and loading code with circular dependencies. This paper also presents the integration of this solution into Pharo regarding the needed Meta-Object Protocol for Undefined Classes and the required modifications of existing tools.},
  series = {IWST '17},
  isbn = {978-1-4503-5554-4},
  location = {Maribor, Slovenia},
  articleno = {9},
  numpages = {8},
  address = {New York, NY, USA},
  inria = {RMOD},
  keywords = {Software engineering ; Programming languages ; Pharo ; Reflection ; Dynamic Languages ; Partial Code Loading; lse-pub kzLanguageDesign},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17b-IWST-UndefinedClasses.pdf},
  hal-id = {hal-01585305}}

@article{Poli17c,
  author = {Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Run-Fail-Grow: Creating Tailored Object-Oriented Runtimes},
  journal = {The Journal of Object Technology},
  volume = {16},
  pages = {2:1-36},
  year = {2017},
  url = {https://hal.archives-ouvertes.fr/hal-01609295},
  doi = {10.5381/jot.2017.16.3.a2},
  annote = {internationaljournal},
  abstract = {Producing a small deployment version of an application is a challenge because static abstractions such as packages cannot anticipate the use of their parts at runtime. Thus, an application often occupies more memory than actually needed. Tailoring is one of the main solutions to this problem i.e., extracting used code units such as classes and methods of an application. However, existing tailoring techniques are mostly based on static type annotations. These techniques cannot efficiently tailor applications in all their extent (e.g., runtime object graphs and metadata) nor be used in the context of dynamically-typed languages. We propose a run-fail-grow technique to tailor applications using their runtime execution. Run-fail-grow launches (a) a reference application containing the original application to tailor and (b) a nurtured application containing only a seed with a minimal set of code units the user wants to ensure in the final application. The nurtured application is executed, failing when it founds missing objects, classes or methods. On failure, the necessary elements are installed into the nurtured application from the reference one, and the execution resumes. The nurtured application is executed until it finishes, or until the developer explicitly finishes it, for example in the case of a web application. resulting in an object memory (i.e., a heap) with only objects, classes and methods required to execute the application. To validate our approach we implemented a tool based on Virtual Machine modifications, namely Tornado. Tornado succeeds to create very small memory footprint versions of applications e.g., a simple object-oriented heap of 11kb. We show how tailoring works on application code, base and third-party libraries even supporting human interaction with user G. interfaces. These experiments show memory savings ranging from 95\% to 99\%.},
  number = {3},
  keywords = {lse-pub kzLanguageDesign kzInfrastructure},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17c-JOT-Tornado.pdf},
  pdf-second = {http://www.jot.fm/issues/issue_2017_03/article2.pdf},
  hal-id = {hal-01609295}}

@article{Poli17d,
  author = {Guillermo Polito and St\'ephane Ducasse and Luc Fabresse and Camille Teruel},
  title = {Scoped Extension Methods in Dynamically-Typed Languages},
  journal = {The Art, Science, and Engineering of Programming},
  volume = {2},
  year = {2018},
  url = {https://hal.archives-ouvertes.fr/hal-01609310},
  doi = {10.22152/programming-journal.org/2018/2/1},
  annote = {internationaljournal},
  number = {1},
  pages = {1-26},
  month = aug,
  keywords = {lse-pub kzLanguageDesign},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Poli17d-Programming-ScopedExtensions.pdf},
  hal-id = {hal-01609310}}

@inproceedings{Poli19a,
  author = {Polito, Guillermo and Tesone, Pablo and Miranda, Eliot and Simmons, David},
  title = {{GildaVM: a Non-Blocking I/O Architecture for the Cog VM}},
  booktitle = {{International Workshop on Smalltalk Technologies}},
  year = {2019},
  url = {https://hal.archives-ouvertes.fr/hal-02379275},
  address = {Cologne, Germany},
  month = aug,
  annote = {internationalworkshop},
  keywords = {lse-pub virtual machines ; multhreading ; non-blocking I/O ; foreign function calls},
  pdf = {https://hal.archives-ouvertes.fr/hal-02379275/file/main.pdf},
  hal-id = {hal-02379275}}
  
@inproceedings{Rogl19a,
  author = {Rogliano, Th{\'e}o and Polito, Guillermo and Tesone, Pablo},
  title = {{Towards easy program migration using language virtualization}},
  booktitle = {{International Workshop of Smalltalk Technology 2019}},
  year = {2019},
  url = {https://hal.archives-ouvertes.fr/hal-02297756},
  address = {K{\"o}ln, Germany},
  month = aug,
  annote = {internationalworkshop},
  keywords = {Migration ; modularity ; virtualization; lse-pub},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02297756/file/TowardsEasyVirtualization.pdf},
  hal-id = {hal-02297756}}
  
@inproceedings{Teso16a,
  author = {Tesone, Pablo and Polito, Guillermo and Fabresse, Luc and Bouraqadi, Noury and Ducasse, St\'ephane},
  title = {Instance Migration in Dynamic Software Update},
  booktitle = {Meta'16},
  year = {2016},
  url = {https://hal.inria.fr/hal-01611600},
  annote = {internalworkshop},
  address = {Amsterdam, Netherlands},
  month = oct,
  keywords = {Object-oriented Languages ; Dynamic Software Update ;	State Migration ; Object Oriented Programming ; DSU ;	OOP ;	Pharo ;	Meta-programming; lse-pub kzLanguageDesign kzInfrastructure kzPharo},
  hal-pdf = {https://hal.inria.fr/hal-01611600/file/main.pdf},
  hal-id = {hal-01611600}}

@article{Teso17b,
  author = {Pablo Tesone and Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Dynamic Software Update from Development to Production},
  journal = {Journal of Object Technology},
  publisher = {AITO - Association Internationale pour les Technologies Objets},
  year = {2018},
  volume ={17},
  pages = {1--36},
  doi = {10.5381/jot.2018.17.1.a2},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso17b-JOT-DynamicUpdate.pdf},
  annote = {internationaljournal},
  abstract = {Dynamic Software Update (DSU) solutions update applications while they are executing. These solutions are typically used in production to minimize application downtime, or in integrated development environments to provide live programming support. Each of these scenarios presents different challenges, forcing existing solutions to be designed with only one of these use cases in mind. For example, DSUs for live programming typically do not implement safe point detection or instance migration, while production DSUs require manual generation of patches and lack IDE integration. Also, these solutions have limited ability to update themselves or the language core libraries, and some of them present execution penalties outside the update window. We propose a DSU (gDSU) that works for both live programming and production environments. Our solution implements safe update point detection using call stack manipulation and a reusable instance migration mechanism to minimize manual intervention in patch generation. Moreover, it also offers updates of core language libraries and the update mechanism itself. This is achieved by the incremental copy of the modified objects and an atomic commit operation. We show that our solution does not affect the global performance of the application and it presents only a run-time penalty during the update window. Our solution is able to apply an update impacting 100,000 instances in 1 second. In this 1 second, only during 250 milliseconds the application is not responsive. The rest of the time the application runs normally while gDSU is looking for the safe update point. The update only requires to copy the elements that are modified.},
  keywords = {pharo lse-pub},
  hal-id = {hal-01920362}}

@inproceedings{Teso18a,
  author = {Tesone, Pablo and Polito, Guillermo and Fabresse, Luc and Bouraqadi, Noury and Ducasse, St\'ephane},
  title = {Implementing Modular Class-based Reuse Mechanisms on Top of a Single Inheritance VM},
  booktitle = {Symposium on Applied Computing (SAC'18)},
  year = {2018},
  url = {https://hal.archives-ouvertes.fr/hal-01812612},
  doi = {10.1145/3167132.3167244},
  annote = {internationalconference},
  abstract = {Code reuse is a good strategy to avoid code duplication and speed up software development. Existing object-oriented programming languages propose different ways of combining existing and new code such as e.g., single inheritance, multiple inheritance, Traits or Mixins. All these mechanisms present advantages and disadvantages and there are situations that require the use of one over the other. To avoid the complexity of implementing a virtual machine (VM), many of these mechanisms are often implemented on top of an existing high-performance VM, originally meant to run a single inheritance object-oriented language. These implementations require thus a mapping between the programming model they propose and the execution model provided by the VM. Moreover, reuse mechanisms are not usually composable, nor it is easy to implement new ones for a given language. In this paper, we propose a modular meta-level runtime architecture to implement and combine different code reuse mechanisms. This architecture supports dynamic combination of several mechanisms without affecting runtime performance in a single inheritance object-oriented VM. It includes moreover a reflective Meta-Object Protocol to query and modify classes using the programming logical model instead of the underlying low-level runtime model. Thanks to this architecture, we implemented Stateful Traits, Mixins, CLOS multiple inheritance, CLOS Standard Method Combinations and Beta prefixing in a modular and composable way.},
  address = {Pau, France},
  month = apr,
  keywords = {lse-pub pharo kzInfrastructure kzLanguage},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso18a-SAC-ExtensibleMetaclasses.pdf},
  hal-id = {hal-01812612}}
  
@inproceedings{conf/iwst/GriggioLPDP11,
  added-at = {2018-11-06T00:00:00.000+0100},
  author = {Griggio, Carla F. and Leiva, Germán and Polito, Guillermo and Decuzzi, Gisela and Passerini, Nicolás},
  biburl = {https://www.bibsonomy.org/bibtex/2401c03f56df5a50e81015ca547ac4700/dblp},
  booktitle = {IWST},
  crossref = {conf/iwst/2011},
  editor = {Lagadec, Loïc and Plantec, Alain},
  ee = {https://doi.org/10.1145/2166929.2166934},
  interhash = {465f71c5e7ee67ef5029355afbd99ece},
  intrahash = {401c03f56df5a50e81015ca547ac4700},
  isbn = {978-1-4503-1050-5},
  keywords = {dblp},
  pages = {5:1-5:5},
  publisher = {ACM},
  timestamp = {2018-11-07T13:49:36.000+0100},
  title = {A programming environment supporting a prototype-based introduction to OOP.},
  url = {http://dblp.uni-trier.de/db/conf/iwst/iwst2011.html#GriggioLPDP11},
  year = 2011
}



@article{Teso20a,
  author = {Pablo Tesone and Guillermo Polito and Luc Fabresse and Noury Bouraqadi and St\'ephane Ducasse},
  title = {Preserving Instance State during Refactorings in Live Environments},
  journal = {Future Generation Computer Systems},
  publisher = {Elsevier},
  volume  = {110},
  doi = {10.1016/j.future.2020.04.010},
  pages = {1-17},
  year = {2020},
  annote = {internationaljournal},
  hal-pdf = {https://hal.archives-ouvertes.fr/hal-02541754/file/main.pdf},
  pdf = {http://rmod-files.lille.inria.fr/Team/Texts/Papers/Teso20a-FutureGeneration-PreservingInstance.pdf},
  keywords = {pharo lse-pub kzLanguageDesign}}
  
@inproceedings{DBLP:conf/dls/MarraPB20,
  author    = {Matteo Marra and
               Guillermo Polito and
               Elisa Gonzalez Boix},
  editor    = {Matthew Flat},
  title     = {Framework-aware debugging with stack tailoring},
  booktitle = {{DLS} 2020: Proceedings of the 16th {ACM} {SIGPLAN} International
               Symposium on Dynamic Languages, Virtual Event, USA, November 17, 2020},
  pages     = {71--84},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3426422.3426982},
  doi       = {10.1145/3426422.3426982},
  timestamp = {Mon, 01 Mar 2021 12:01:06 +0100},
  biburl    = {https://dblp.org/rec/conf/dls/MarraPB20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@article{Gaut19a,
  author  = {Guillaume Gautier and Guillermo Polito and R{{\'e}}mi Bardenet and Michal Valko},
  title   = {DPPy: DPP Sampling with Python},
  journal = {Journal of Machine Learning Research},
  year    = {2019},
  volume  = {20},
  number  = {180},
  pages   = {1-7},
  url     = {http://jmlr.org/papers/v20/19-179.html}
}

@article{Marr20a,
title = {A debugging approach for live Big Data applications},
journal = {Science of Computer Programming},
volume = {194},
pages = {102460},
year = {2020},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2020.102460},
url = {https://www.sciencedirect.com/science/article/pii/S0167642320300708},
author = {Matteo Marra and Guillermo Polito and Elisa {Gonzalez Boix}},
keywords = {Online debugging, Big Data, Map/reduce, Live programming},
abstract = {Many frameworks exist for programmers to develop and deploy Big Data applications such as Hadoop Map/Reduce and Apache Spark. However, very little debugging support is currently provided in those frameworks. When an error occurs, developers are lost in trying to understand what has happened from the information provided in log files. Recently, new solutions allow developers to record & replay the application execution, but replaying is not always affordable when hours of computation need to be re-executed. In this paper, we present an online approach that allows developers to debug Big Data applications in isolation by moving the debugging session to an external process when a halting point is reached. We introduce IDRAMR, our prototype implementation in Pharo. IDRAMR centralizes the debugging of parallel applications by introducing novel debugging concepts, such as composite debugging events, and the ability to dynamically update both the code of the debugged application and the same configuration of the running framework. We validate our approach by debugging both application and configuration failures for two driving scenarios. The scenarios are implemented and executed using Port, our Map/Reduce framework for Pharo, also introduced in this paper.}
}

@techreport{boulet:hal-01432133,
  TITLE = {{N2S3, an Open-Source Scalable Spiking Neuromorphic Hardware Simulator}},
  AUTHOR = {Boulet, Pierre and Devienne, Philippe and Falez, Pierre and Polito, Guillermo and Shahsavari, Mahyar and Tirilly, Pierre},
  URL = {https://hal.archives-ouvertes.fr/hal-01432133},
  TYPE = {Research Report},
  INSTITUTION = {{Universit{\'e} de Lille 1, Sciences et Technologies ; CRIStAL UMR 9189}},
  YEAR = {2017},
  MONTH = Jan,
  KEYWORDS = { simulation ;  neuromorphic architecture ;  SNN ; SPiking neural networks},
  PDF = {https://hal.archives-ouvertes.fr/hal-01432133v1/file/n2s3.pdf},
  HAL_ID = {hal-01432133},
  HAL_VERSION = {v1},
}